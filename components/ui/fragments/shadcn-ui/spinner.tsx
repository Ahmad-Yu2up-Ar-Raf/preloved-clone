import { THEME } from '@/lib/theme';
import { Text } from './text';

import { cn } from '@/lib/utils';
import { Loader2 } from 'lucide-react-native';
import React, { useEffect, useMemo } from 'react';
import { ActivityIndicator, View } from 'react-native';
import Animated, {
  Easing,
  SharedValue,
  useAnimatedStyle,
  useSharedValue,
  withDelay,
  withRepeat,
  withSequence,
  withTiming,
} from 'react-native-reanimated';
import { useColorScheme } from 'nativewind';

type SpinnerSize = 'default' | 'sm' | 'lg' | 'icon';
export type SpinnerVariant = 'default' | 'circle' | 'dots' | 'pulse' | 'bars';

interface SpinnerProps {
  size?: SpinnerSize;
  variant?: SpinnerVariant;
  label?: string;
  showLabel?: boolean;
  className?: string;
  color?: string;
  speed?: 'slow' | 'normal' | 'fast';
}

interface LoadingOverlayProps extends SpinnerProps {
  visible: boolean;
  backdrop?: boolean;
  backdropOpacity?: number;
  onRequestClose?: () => void;
}

interface SpinnerConfig {
  size: number;
  iconSize: number;
  fontSize: number;
  gap: number;
}

const sizeConfig: Record<SpinnerSize, SpinnerConfig> = {
  sm: { size: 16, iconSize: 16, fontSize: 12, gap: 6 },
  default: { size: 24, iconSize: 24, fontSize: 14, gap: 8 },
  lg: { size: 32, iconSize: 32, fontSize: 16, gap: 10 },
  icon: { size: 24, iconSize: 24, fontSize: 14, gap: 8 },
};

const speedConfig = {
  slow: 1500,
  normal: 1000,
  fast: 500,
};

interface AnimatedShapeProps {
  anim: SharedValue<number>;
  color: string;
  size: number;
  className?: string;
}

const AnimatedDot = React.memo(({ anim, color, size, className }: AnimatedShapeProps) => {
  const animatedStyle = useAnimatedStyle(() => ({
    opacity: anim.value,
  }));

  return (
    <Animated.View
      className={cn('rounded-full', className)}
      style={[{ width: size, height: size, backgroundColor: color }, animatedStyle]}
    />
  );
});

const AnimatedBar = React.memo(({ anim, color, size, className }: AnimatedShapeProps) => {
  const animatedStyle = useAnimatedStyle(() => ({
    opacity: anim.value,
  }));

  return (
    <Animated.View
      className={cn('rounded-lg', className)}
      style={[{ width: size / 6, height: size, backgroundColor: color }, animatedStyle]}
    />
  );
});

export function Spinner({
  size = 'default',
  variant = 'default',
  label,
  showLabel = false,
  className,
  color,
  speed = 'normal',
}: SpinnerProps) {
  const rotate = useSharedValue(0);
  const pulse = useSharedValue(1);

  const dotAnim1 = useSharedValue(0.3);
  const dotAnim2 = useSharedValue(0.3);
  const dotAnim3 = useSharedValue(0.3);

  const barAnim1 = useSharedValue(0.3);
  const barAnim2 = useSharedValue(0.3);
  const barAnim3 = useSharedValue(0.3);
  const barAnim4 = useSharedValue(0.3);

  const dotsAnims = useMemo(() => [dotAnim1, dotAnim2, dotAnim3], [dotAnim1, dotAnim2, dotAnim3]);

  const barsAnims = useMemo(
    () => [barAnim1, barAnim2, barAnim3, barAnim4],
    [barAnim1, barAnim2, barAnim3, barAnim4]
  );
  const tintColor = THEME.light.primaryForeground;

  const config = sizeConfig[size];
  const spinnerColor = color || tintColor;
  const animationDuration = speedConfig[speed];

  useEffect(() => {
    if (variant === 'circle') {
      rotate.value = withRepeat(
        withTiming(360, { duration: animationDuration, easing: Easing.linear }),
        -1
      );
    } else {
      rotate.value = 0;
    }
  }, [rotate, variant, animationDuration]);

  useEffect(() => {
    if (variant === 'pulse') {
      pulse.value = withRepeat(
        withSequence(
          withTiming(1.3, { duration: animationDuration / 2 }),
          withTiming(1, { duration: animationDuration / 2 })
        ),
        -1,
        true
      );
    } else {
      pulse.value = 1;
    }
  }, [pulse, variant, animationDuration]);

  useEffect(() => {
    if (variant === 'dots') {
      dotsAnims.forEach((anim, index) => {
        anim.value = withRepeat(
          withSequence(
            withDelay(
              index * (animationDuration / 6),
              withTiming(1, { duration: animationDuration / 3 })
            ),
            withTiming(0.3, { duration: animationDuration / 3 })
          ),
          -1
        );
      });
    } else {
      dotsAnims.forEach((anim) => (anim.value = 0.3));
    }
  }, [dotsAnims, variant, animationDuration]);

  useEffect(() => {
    if (variant === 'bars') {
      barsAnims.forEach((anim, index) => {
        anim.value = withRepeat(
          withSequence(
            withDelay(
              index * (animationDuration / 8),
              withTiming(1, { duration: animationDuration / 4 })
            ),
            withTiming(0.3, { duration: animationDuration / 4 })
          ),
          -1
        );
      });
    } else {
      barsAnims.forEach((anim) => (anim.value = 0.3));
    }
  }, [barsAnims, variant, animationDuration]);

  const animatedCircleStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotate.value}deg` }],
  }));

  const animatedPulseStyle = useAnimatedStyle(() => ({
    transform: [{ scale: pulse.value }],
  }));

  const renderSpinner = () => {
    switch (variant) {
      case 'default':
        return (
          <ActivityIndicator size={config.size} color={spinnerColor} className="self-center" />
        );

      case 'circle':
        return (
          <Animated.View
            className="items-center justify-center"
            style={[{ width: config.size, height: config.size }, animatedCircleStyle]}>
            <Loader2 size={config.iconSize} color={spinnerColor} />
          </Animated.View>
        );

      case 'pulse':
        return (
          <Animated.View
            className="rounded-full"
            style={[
              {
                width: config.size,
                height: config.size,
                backgroundColor: spinnerColor,
              },
              animatedPulseStyle,
            ]}
          />
        );

      case 'dots':
        return (
          <View className="flex-row items-center justify-center" style={{ gap: config.size / 4 }}>
            {dotsAnims.map((anim, index) => (
              <AnimatedDot key={index} anim={anim} color={spinnerColor} size={config.size / 3} />
            ))}
          </View>
        );

      case 'bars':
        return (
          <View className="flex-row items-center justify-center" style={{ gap: config.size / 6 }}>
            {barsAnims.map((anim, index) => (
              <AnimatedBar key={index} anim={anim} color={spinnerColor} size={config.size} />
            ))}
          </View>
        );

      default:
        return null;
    }
  };

  return (
    <View className={cn('items-center justify-center', className)} style={{ gap: config.gap }}>
      {renderSpinner()}
      {(showLabel || label) && (
        <Text
          className="text-center font-medium text-foreground"
          style={{ fontSize: config.fontSize }}>
          {label || 'Loading...'}
        </Text>
      )}
    </View>
  );
}

export function LoadingOverlay({
  visible,
  backdrop = true,
  backdropOpacity = 0.5,
  ...spinnerProps
}: LoadingOverlayProps) {
  const opacity = useSharedValue(0);
  const { colorScheme } = useColorScheme();
  const currentTheme = colorScheme ?? 'light';
  const background = THEME[currentTheme].background;
  const card = THEME[currentTheme].card;

  useEffect(() => {
    opacity.value = withTiming(visible ? 1 : 0, {
      duration: 200,
    });
  }, [visible, opacity]);

  const animatedOverlayStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
    display: opacity.value === 0 ? 'none' : 'flex',
  }));

  const backdropColor = `${background}${Math.round(backdropOpacity * 255)
    .toString(16)
    .padStart(2, '0')}`;

  return (
    <Animated.View
      className="absolute inset-0 z-[9999] items-center justify-center"
      style={[{ backgroundColor: backdrop ? backdropColor : 'transparent' }, animatedOverlayStyle]}
      pointerEvents={visible ? 'auto' : 'none'}>
      <View className="p-15 rounded-lg" style={{ backgroundColor: card }}>
        <Spinner {...spinnerProps} />
      </View>
    </Animated.View>
  );
}

export function InlineLoader({
  size = 'sm',
  variant = 'default',
  color,
}: Omit<SpinnerProps, 'label' | 'showLabel'>) {
  return <Spinner size={size} variant={variant} color={color} className="min-h-0 min-w-0" />;
}

export function ButtonSpinner({
  size = 'sm',
  variant = 'default',
  color,
}: Omit<SpinnerProps, 'label' | 'showLabel'>) {
  const { colorScheme } = useColorScheme();
  const currentTheme = colorScheme ?? 'light';
  const primaryForeground = THEME[currentTheme].primaryForeground;

  return (
    <Spinner
      size={size}
      variant={variant}
      color={color || primaryForeground}
      className="min-h-0 min-w-0"
    />
  );
}
